---
title: C++ 学习主题
top: false
mathjax: true
categories:
- C++
---

-----



C++ 类型转换

C++ 内存对齐

C++ 字面量

C++ 异常

C++ const volatile

C++ const 关键字

​	const * int 和int *const、const int * cosnt、const int &

> ​	*参考链接：*[const int、const int *、int *cosnt、const int * const、const int &的区别](https://blog.csdn.net/itworld123/article/details/78967080);
>
> - `int const *`:该指针变量指向的是常量，即该指针变量的内容可以改变，但是该内容指向的内容不可改变！;即底层const(常量指针)；（其与`const int *`相同）；
> - `int *const`:声明该指针变量为常变量，即指针变量里面的内容不可改变，但是该内容指向的内容可以改变;即为常指针。
> - `const int * cosnt`:指向一个内容不可变的指针，且指向对象地址不能变；
> - `const int &`:在引用前面加上const，代表该引用为常引用，即被引用的对象不可改变。若是在形参中使用，则不可达到在函数里面修改变量值的目的。

C++ 左值右值

> *参考链接*：[理解C和C++中的左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310);[C++11 左值、右值、右值引用详解](https://blog.csdn.net/hyman_yx/article/details/52044632);
>
> 左值：代表一个在内存中占有确定位置的对象(存在地址);例如`int a=0;`中`a`就是一个左值 右值：通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。
>
> **左值引用**就是对一个左值进行引用的类型。**右值引用**就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。
>
> 右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。
>
> 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。

C++  位操作

C++ 类型转换

函数重载(overloaded 和over)

C++ 初值列

> ### initialzer_list 形参
>
> 当函数的实参数量未知；但是全部实参的类型相同，我们可以使用initializer_list类型的形参。详细描述如下表：
>
> | 操作                                  | 解释                                                         |
> | :------------------------------------ | :----------------------------------------------------------- |
> | `initializer_list <T> lst`            | 默认初始化；类型的空列表                                     |
> | `initializer_list <T> lst {a,b,c...}` | lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const |
> | `lst2(lst) or lst2=lst`               | 拷贝复制一个元素                                             |
> | `lst.size()`                          | 列表中的元素数量                                             |
> | `lst.begin()`                         | 返回指向lst中首元素的指针                                    |
> | `lst.end()`                           | 返回指向lst中尾元素下一位置的指针                            |
>
> 下面是代码示例：

C++ 帮助调试

> ##### 帮助调试
>
> c++中有许多帮助调试的信息；其中包括`assert`预处理宏；在`<assert>`头文件中定义。`assert(expr)`中判断表达式为假时，函数终止。 同时还存在NDEBUG预处理变量;使用静态预处理变量，说明当前文件信息。
>
> |   关键字   | 作用                       |
> | :--------: | :------------------------- |
> | `__FILE__` | 存放文件名字的字符串字面值 |
> | `__LINE__` | 存放当前行号整形字面值     |
> | `__TIME__` | 存放编译时间字符串字面值   |
> | `__DATE__` | 存放编译日期字符串字面值   |

在*Visual Studio*中可以设置`main`函数调试参数：



C++ IO 基础





cmake configure_file





c++ 单例模式

RAII

constexpr if

> 警告C4127：条件表达式是常量